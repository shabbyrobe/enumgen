package enumgen

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/constant"
	"go/types"
	"io"
	"sort"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

const preamble = "Code generated by 'github.com/shabbyrobe/enumgen'. DO NOT EDIT."

type kind int

const (
	intKind    kind = 1
	stringKind kind = 2
)

type flagMode string

const (
	flagNone flagMode = "none"
	flagVal  flagMode = "val"
	flagGet  flagMode = "get"
)

func (m flagMode) WithFlag() bool { return m != "" && m != flagNone }
func (m flagMode) String() string { return string(m) }

func (m *flagMode) Set(s string) error {
	*m = flagMode(s)
	if *m == flagNone || *m == "false" { // "false" is for backward compatibility
		*m = ""
		return nil
	}
	if *m != "" && *m != flagVal && *m != flagGet {
		return fmt.Errorf("unknown flag mode; must be 'none', 'get' or 'val'")
	}
	return nil
}

type packageInfo struct {
	fullName string
	name     string
	defs     map[*ast.Ident]types.Object
}

func (pkg *packageInfo) findType(name string) (types.Object, error) {
	var def types.Object
	for _, cur := range pkg.defs {
		if cur == nil {
			continue
		}
		if _, ok := cur.Type().(*types.Named); !ok {
			continue
		}
		if cur.Name() == name {
			def = cur
			break
		}
	}
	if def == nil {
		return nil, fmt.Errorf("enumgen: could not find def for %s", name)
	}

	return def, nil
}

type constantValue struct {
	Name      string
	LowerName string
	Value     string
	Const     *types.Const
}

type constants struct {
	FullName     string
	Name         string
	Empty        string
	Kind         kind
	ValuesString string
	IsNamedType  bool
	Basic        *types.Basic

	values     []constantValue
	nameOrder  []constantValue
	valueOrder []constantValue
}

func (cns *constants) IntParseBits() int {
	switch cns.Basic.Kind() {
	case types.Int8, types.Uint8:
		return 8
	case types.Int16, types.Uint16:
		return 16
	case types.Int32, types.Uint32:
		return 32
	case types.Int64, types.Uint64:
		return 64
	case types.Int, types.Uint:
		return 0
	default:
		return -1
	}
}

func (cns *constants) NameOrder() []constantValue {
	if cns.nameOrder == nil {
		cns.nameOrder = make([]constantValue, len(cns.values))
		copy(cns.nameOrder, cns.values)
		sort.Slice(cns.nameOrder, func(i, j int) bool {
			return cns.nameOrder[i].Name < cns.nameOrder[j].Name
		})
	}
	return cns.nameOrder
}

func (cns constants) ValueOrder() []constantValue {
	if cns.valueOrder == nil {
		cns.valueOrder = make([]constantValue, len(cns.values))
		copy(cns.valueOrder, cns.values)
		sort.Slice(cns.valueOrder, func(i, j int) bool {
			return cns.valueOrder[i].Value < cns.valueOrder[j].Value
		})
	}
	return cns.valueOrder
}

type switches struct {
	FlagMode         flagMode
	WithMarshal      bool
	WithString       bool
	WithName         bool
	WithLookup       bool
	WithIsValid      bool
	WithValues       bool
	WithValuesString bool
}

type generator struct {
	buf    bytes.Buffer
	format bool
	switches
}

func (g *generator) Output(fileName string, pkgInfo *packageInfo) ([]byte, error) {
	var out bytes.Buffer
	out.Write([]byte("// " + preamble))
	out.WriteString("\n\n")
	out.WriteString(fmt.Sprintf("package %s", pkgInfo.name))
	io.Copy(&out, &g.buf)

	bts := out.Bytes()
	if g.format {
		var err error
		bts, err = imports.Process(fileName, bts, nil)
		if err != nil {
			return nil, err
		}
	}
	return bts, nil
}

func (g *generator) extract(pkg *packageInfo, typeName string) (*constants, error) {
	def, err := pkg.findType(typeName)
	if err != nil {
		return nil, err
	}

	fullName := pkg.fullName + "." + typeName

	_, isNamed := def.Type().(*types.Named)
	cs := &constants{
		FullName:    fullName,
		Name:        typeName,
		IsNamedType: isNamed,
	}

	cs.Basic = def.Type().Underlying().(*types.Basic)
	underlying := cs.Basic.Info()
	if underlying&types.IsInteger != 0 {
		cs.Empty = "0"
		cs.Kind = intKind

	} else if underlying&types.IsString != 0 {
		cs.Empty = `""`
		cs.Kind = stringKind

	} else {
		return nil, fmt.Errorf("type %q is not a string or integer type", typeName)
	}

	var seenNames = map[string]bool{}
	for _, cur := range pkg.defs {
		if cur == nil {
			continue
		}

		if cur.Type().String() != fullName {
			continue
		}

		if cns, ok := cur.(*types.Const); ok {
			lowerName := strings.ToLower(cns.Name())
			if seenNames[lowerName] {
				return nil, fmt.Errorf("enumgen: type %q contained duplicate constant name %q (after case is discarded)", typeName, cns.Name())
			}
			seenNames[lowerName] = true
			cs.values = append(cs.values, constantValue{
				Name:      cns.Name(),
				LowerName: lowerName,
				Value:     cns.Val().ExactString(),
				Const:     cns,
			})
		}
	}

	sort.Slice(cs.values, func(i, j int) bool {
		return cs.values[i].Value < cs.values[j].Value
	})

	{ // Build ValuesString:
		if cs.Kind == stringKind {
			vstrs := make([]string, 0, len(cs.values))
			for _, v := range cs.ValueOrder() {
				vstrs = append(vstrs, constant.StringVal(v.Const.Val()))
			}
			cs.ValuesString = strings.Join(vstrs, ", ")
		}
	}

	return cs, nil
}

func (g *generator) parsePackage(pkgName string, tags []string) (*packageInfo, error) {
	cfg := &packages.Config{
		Mode:       packages.LoadSyntax,
		Tests:      false,
		BuildFlags: []string{fmt.Sprintf("-tags=%s", strings.Join(tags, " "))},
	}
	pkgs, err := packages.Load(cfg, pkgName)
	if err != nil {
		return nil, err
	}
	if len(pkgs) != 1 {
		return nil, fmt.Errorf("package %q not found", pkgName)
	}

	pkg := pkgs[0]
	return &packageInfo{
		fullName: pkg.PkgPath,
		name:     pkg.Name,
		defs:     pkg.TypesInfo.Defs,
	}, nil
}

func (g *generator) generate(cns *constants) error {
	if g.switches.FlagMode != "" {
		g.switches.WithString = true
	}

	var data = &templateData{
		switches:  g.switches,
		Receiver:  "v",
		Unknown:   "<unknown>",
		Constants: cns,
		Type:      cns.Name,
	}
	if err := genTpl.Execute(&g.buf, data); err != nil {
		return err
	}

	var tpl *template.Template
	switch cns.Kind {
	case intKind:
		tpl = intTpl
	case stringKind:
		tpl = strTpl
	default:
		return fmt.Errorf("unsupported kind")
	}
	if err := tpl.Execute(&g.buf, data); err != nil {
		return err
	}

	return nil
}
